import React, { useEffect, useState, useRef, useMemo, createContext, useContext } from 'react';
import ReactMarkdown from 'react-markdown';

// Context to determine if we are inside an ordered list
const ListTypeContext = createContext({ ordered: false });

interface TypewriterProps {
  content: string;
  isStreaming: boolean;
  onComplete?: () => void;
  onOptionClick?: (text: string) => void;
}

const Typewriter: React.FC<TypewriterProps> = ({ content, isStreaming, onComplete, onOptionClick }) => {
  const [displayedContent, setDisplayedContent] = useState('');
  const [isVisualTyping, setIsVisualTyping] = useState(false);
  const bottomRef = useRef<HTMLDivElement>(null);

  // Audio Refs
  const audioCtxRef = useRef<AudioContext | null>(null);
  const lastSoundTime = useRef<number>(0);

  // Buffering Refs for slow typing effect
  const contentRef = useRef(content);
  const displayedLengthRef = useRef(0);

  // Custom renderer for list items to make them clickable, and for auto-linked SCP numbers
  const markdownComponents = useMemo(() => ({
    ol: ({ children, ...props }: any) => (
        <ListTypeContext.Provider value={{ ordered: true }}>
            <ol {...props}>{children}</ol>
        </ListTypeContext.Provider>
    ),
    ul: ({ children, ...props }: any) => (
        <ListTypeContext.Provider value={{ ordered: false }}>
            <ul {...props}>{children}</ul>
        </ListTypeContext.Provider>
    ),
    li: ({ children, ...props }: any) => {
        const { ordered } = useContext(ListTypeContext);

        // Helper to recursively extract text from React children
        const extractText = (nodes: React.ReactNode): string => {
            let text = '';
            React.Children.forEach(nodes, (child) => {
                if (typeof child === 'string') {
                    text += child;
                } else if (typeof child === 'number') {
                    text += String(child);
                } else if (React.isValidElement(child)) {
                    const element = child as React.ReactElement<{ children?: React.ReactNode }>;
                    if (element.props.children) {
                        text += extractText(element.props.children);
                    }
                } else if (Array.isArray(child)) {
                    child.forEach(c => text += extractText(c));
                }
            });
            return text;
        };

        const textContent = extractText(children);
        // Only allow clicking if it's an ordered list AND we have a handler
        const isClickable = ordered && !!onOptionClick && textContent.trim().length > 0;

        return (
            <li 
                {...props} 
                className={isClickable ? "cursor-pointer hover:text-scp-term hover:bg-scp-gray/20 transition-all duration-200 rounded px-2 -ml-2 group relative" : ""}
                onClick={(e) => {
                    const selection = window.getSelection();
                    // If text is selected, do not trigger the click action
                    if (selection && selection.toString().length > 0) {
                        return;
                    }

                    if (isClickable && onOptionClick) {
                        e.stopPropagation();
                        // Removing potential leading numbering/bullets if they somehow end up in text (though usually they don't in li)
                        onOptionClick(textContent.trim()); 
                    }
                }}
                title={isClickable ? "点击自动填入 (Click to fill)" : undefined}
            >
                {isClickable && (
                   <span className="absolute -left-4 top-1/2 -translate-y-1/2 text-scp-term opacity-0 group-hover:opacity-100 transition-opacity">›</span>
                )}
                {children}
            </li>
        );
    },
    a: ({ href, children, ...props }: any) => {
        // Handle custom SCP links generated by regex replacement (format: #scp-SCP-XXX)
        if (href && href.startsWith('#scp-')) {
            const scpId = href.replace('#scp-', '');
            const isClickable = !!onOptionClick;
            
            return (
                <span 
                    className={`text-scp-term underline decoration-scp-term/50 decoration-1 underline-offset-4 transition-all select-text ${isClickable ? 'cursor-pointer hover:decoration-scp-term hover:text-white hover:bg-scp-term/10 rounded px-1 -mx-1' : ''}`}
                    onClick={(e) => {
                        // Allow text selection without triggering click
                        const selection = window.getSelection();
                        if (selection && selection.toString().length > 0) return;

                        if (isClickable && onOptionClick) {
                            e.preventDefault();
                            e.stopPropagation();
                            onOptionClick(scpId); 
                        }
                    }}
                    title={isClickable ? "点击填入 (Click to fill)" : undefined}
                >
                    {children}
                </span>
            );
        }
        // Default link styling for other links
        return (
            <a 
                href={href} 
                className="text-blue-400 hover:text-blue-300 underline" 
                target="_blank" 
                rel="noopener noreferrer"
                {...props}
            >
                {children}
            </a>
        );
    }
  }), [onOptionClick]);

  // Keep contentRef in sync with prop
  useEffect(() => {
    contentRef.current = content;
  }, [content]);

  // Manage Audio Context based on visual typing state
  useEffect(() => {
    if (isVisualTyping) {
      if (!audioCtxRef.current) {
        const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
        if (AudioContextClass) {
          audioCtxRef.current = new AudioContextClass();
        }
      }
    } else {
      // Close context when not typing to save resources
      if (audioCtxRef.current) {
        if (audioCtxRef.current.state !== 'closed') {
          audioCtxRef.current.close();
        }
        audioCtxRef.current = null;
      }
    }

    return () => {
      if (audioCtxRef.current) {
        if (audioCtxRef.current.state !== 'closed') {
          audioCtxRef.current.close();
        }
        audioCtxRef.current = null;
      }
    };
  }, [isVisualTyping]);

  const playKeystrokeSound = () => {
    const ctx = audioCtxRef.current;
    if (!ctx) return;
    if (ctx.state === 'suspended') ctx.resume();

    const now = ctx.currentTime;
    if (now - lastSoundTime.current < 0.02) return;
    lastSoundTime.current = now;

    const bufferSize = ctx.sampleRate * 0.05; // 50ms
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    // Sound 1: Click
    const clickNoise = ctx.createBufferSource();
    clickNoise.buffer = buffer;
    const clickFilter = ctx.createBiquadFilter();
    clickFilter.type = 'bandpass';
    clickFilter.frequency.value = 2500 + Math.random() * 500; 
    clickFilter.Q.value = 2.0; 
    const clickGain = ctx.createGain();
    clickGain.gain.setValueAtTime(0, now);
    clickGain.gain.linearRampToValueAtTime(0.15, now + 0.005);
    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
    clickNoise.connect(clickFilter);
    clickFilter.connect(clickGain);
    clickGain.connect(ctx.destination);
    clickNoise.start(now);
    clickNoise.stop(now + 0.03);

    // Sound 2: Thud
    const thudNoise = ctx.createBufferSource();
    thudNoise.buffer = buffer;
    const thudFilter = ctx.createBiquadFilter();
    thudFilter.type = 'lowpass';
    thudFilter.frequency.value = 300 + Math.random() * 100;
    const thudGain = ctx.createGain();
    thudGain.gain.setValueAtTime(0, now);
    thudGain.gain.linearRampToValueAtTime(0.3, now + 0.01);
    thudGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
    thudNoise.connect(thudFilter);
    thudFilter.connect(thudGain);
    thudGain.connect(ctx.destination);
    thudNoise.start(now);
    thudNoise.stop(now + 0.05);
  };

  // Typing Loop
  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    const typeStep = () => {
        const target = contentRef.current;
        const currentLen = displayedLengthRef.current;

        // Check if fully complete (backend done AND visual typing done)
        if (!isStreaming && currentLen >= target.length) {
            setIsVisualTyping(false);
            if (onComplete) onComplete();
            return;
        }

        setIsVisualTyping(true);

        if (currentLen < target.length) {
            // Still have content to type from buffer
            const charsToAdd = Math.floor(Math.random() * 5) + 12; 
            const nextLen = Math.min(currentLen + charsToAdd, target.length);
            const nextText = target.slice(0, nextLen);
            
            setDisplayedContent(nextText);
            displayedLengthRef.current = nextLen;
            
            playKeystrokeSound();

            if (bottomRef.current) {
                bottomRef.current.scrollIntoView({ behavior: "smooth" });
            }

            const delay = 50 + Math.random() * 40;
            timeoutId = setTimeout(typeStep, delay);
        } else {
            // Buffer exhausted, but streaming is still true (waiting for backend)
            timeoutId = setTimeout(typeStep, 100);
        }
    };

    // Kick off the loop
    timeoutId = setTimeout(typeStep, 50);

    return () => clearTimeout(timeoutId);
  }, [isStreaming]); 

  // Handle content reset (e.g. new chat)
  useEffect(() => {
      if (content.length === 0) {
          setDisplayedContent('');
          displayedLengthRef.current = 0;
          setIsVisualTyping(false);
      }
  }, [content]);

  // Pre-process content to wrap SCP-XXX patterns in custom links for styling and interaction
  const processedContent = useMemo(() => {
    // Regex matches "SCP-" followed by digits, and optional suffixes like "-JP", "-J", etc.
    // \b ensures we match word boundaries.
    return displayedContent.replace(/\b(SCP-\d+(?:-[A-Za-z0-9]+)*)\b/g, '[$1](#scp-$1)');
  }, [displayedContent]);

  return (
    <div className={`typewriter-container prose prose-invert prose-p:text-scp-text prose-headings:text-scp-accent max-w-none font-mono text-sm md:text-base leading-relaxed ${isVisualTyping ? 'cursor-active' : ''}`}>
      <style>
        {`
          .typewriter-container ol {
            list-style: decimal !important;
            padding-left: 2rem !important;
            margin: 1rem 0 !important;
          }
          .typewriter-container ol ol {
            list-style: lower-alpha !important;
            padding-left: 2.5rem !important;
          }
          .typewriter-container li {
            margin: 0.5rem 0 !important;
          }
          /* Cursor styling attached to the last element */
          @keyframes cursor-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
          }
          .typewriter-container.cursor-active > *:last-child::after {
            content: '▋';
            display: inline-block;
            animation: cursor-blink 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            color: #33ff00;
            margin-left: 4px;
            vertical-align: baseline;
          }
          /* Fallback for empty content */
          .typewriter-container.cursor-active:empty::after {
            content: '▋';
            display: inline-block;
            animation: cursor-blink 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            color: #33ff00;
          }
        `}
      </style>
      
      <ReactMarkdown components={markdownComponents}>{processedContent}</ReactMarkdown>
      <div ref={bottomRef} />
    </div>
  );
};

export default Typewriter;